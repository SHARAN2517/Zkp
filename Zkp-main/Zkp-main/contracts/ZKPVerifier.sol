// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./DeviceRegistry.sol";
import "./IntegrityLog.sol";

/**
 * @title ZKPVerifier
 * @dev Verifies Zero-Knowledge Proofs for IoT device authentication
 * This contract will include the generated verifier from snarkjs
 */
contract ZKPVerifier {
    DeviceRegistry public deviceRegistry;
    IntegrityLog public integrityLog;
    
    // Events
    event ProofVerified(
        bytes32 indexed deviceId,
        address indexed prover,
        bool success,
        uint256 timestamp
    );
    
    event AuthenticationAttempt(
        bytes32 indexed deviceId,
        bool success,
        uint256 timestamp
    );

    // State variables
    mapping(bytes32 => uint256) public lastAuthTimestamp;
    mapping(bytes32 => uint256) public authAttemptCount;
    uint256 public constant AUTH_WINDOW = 300; // 5 minutes
    uint256 public constant MAX_AUTH_ATTEMPTS = 3;
    
    address public admin;

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }

    constructor(address _deviceRegistry) {
        admin = msg.sender;
        deviceRegistry = DeviceRegistry(_deviceRegistry);
    }

    /**
     * @dev Set the IntegrityLog contract address
     * @param _integrityLog Address of the IntegrityLog contract
     */
    function setIntegrityLog(address _integrityLog) external onlyAdmin {
        integrityLog = IntegrityLog(_integrityLog);
    }

    /**
     * @dev Verify ZKP and authenticate device
     * @param deviceId Device identifier
     * @param _pA Proof component A
     * @param _pB Proof component B  
     * @param _pC Proof component C
     * @param publicSignals Public signals for the proof
     * @return bool Success status
     */
    function verifyAndAuthenticate(
        bytes32 deviceId,
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[4] calldata publicSignals
    ) external returns (bool) {
        // Check if device exists and is active
        require(deviceRegistry.isDeviceActive(deviceId), "Device not active");
        
        // Check rate limiting
        require(
            authAttemptCount[deviceId] < MAX_AUTH_ATTEMPTS ||
            block.timestamp > lastAuthTimestamp[deviceId] + AUTH_WINDOW,
            "Too many authentication attempts"
        );
        
        // Reset attempt count if window has passed
        if (block.timestamp > lastAuthTimestamp[deviceId] + AUTH_WINDOW) {
            authAttemptCount[deviceId] = 0;
        }
        
        authAttemptCount[deviceId]++;
        lastAuthTimestamp[deviceId] = block.timestamp;
        
        // Verify the proof (this will be replaced with actual snarkjs generated verifier)
        bool proofValid = _verifyProof(_pA, _pB, _pC, publicSignals);
        
        // Additional validation of public signals
        bool signalsValid = _validatePublicSignals(deviceId, publicSignals);
        
        bool success = proofValid && signalsValid;
        
        if (success) {
            // Reset attempt count on successful auth
            authAttemptCount[deviceId] = 0;
            
            // Log to IntegrityLog if available
            if (address(integrityLog) != address(0)) {
                bytes32 proofHash = _computeProofHash(_pA, _pB, _pC);
                bytes32 dataHash = keccak256(abi.encodePacked(deviceId, block.timestamp));
                integrityLog.logData(deviceId, dataHash, proofHash, true);
            }
        }
        
        emit ProofVerified(deviceId, msg.sender, success, block.timestamp);
        emit AuthenticationAttempt(deviceId, success, block.timestamp);
        
        return success;
    }

    /**
     * @dev Internal function to verify the proof (placeholder)
     * This will be replaced with the actual snarkjs generated verifier
     */
    function _verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[4] calldata publicSignals
    ) internal pure returns (bool) {
        // Placeholder - actual verification logic will be generated by snarkjs
        // For now, return true if proof components are non-zero
        return (
            _pA[0] != 0 && _pA[1] != 0 &&
            _pB[0][0] != 0 && _pB[0][1] != 0 &&
            _pB[1][0] != 0 && _pB[1][1] != 0 &&
            _pC[0] != 0 && _pC[1] != 0 &&
            publicSignals[0] != 0
        );
    }

    /**
     * @dev Validate public signals
     * @param deviceId Device identifier
     * @param publicSignals Array of public signals [secretHash, deviceId, timestamp, isValid]
     */
    function _validatePublicSignals(
        bytes32 deviceId,
        uint[4] calldata publicSignals
    ) internal view returns (bool) {
        // Extract public signals
        bytes32 secretHash = bytes32(publicSignals[0]);
        bytes32 signalDeviceId = bytes32(publicSignals[1]);
        uint256 timestamp = publicSignals[2];
        uint256 isValid = publicSignals[3];
        
        // Verify device ID matches
        if (signalDeviceId != deviceId) {
            return false;
        }
        
        // Verify timestamp is within acceptable window
        if (timestamp < block.timestamp - AUTH_WINDOW || timestamp > block.timestamp + 60) {
            return false;
        }
        
        // Verify secret hash matches registered hash
        bytes32 registeredHash = deviceRegistry.getSecretHash(deviceId);
        if (secretHash != registeredHash) {
            return false;
        }
        
        // Verify the proof claims to be valid
        if (isValid != 1) {
            return false;
        }
        
        return true;
    }

    /**
     * @dev Compute hash of proof components for logging
     */
    function _computeProofHash(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_pA, _pB, _pC));
    }

    /**
     * @dev Get authentication statistics for a device
     * @param deviceId Device identifier
     * @return lastAuth, attemptCount, isRateLimited
     */
    function getAuthStats(bytes32 deviceId) 
        external 
        view 
        returns (uint256, uint256, bool) 
    {
        bool isRateLimited = (
            authAttemptCount[deviceId] >= MAX_AUTH_ATTEMPTS &&
            block.timestamp <= lastAuthTimestamp[deviceId] + AUTH_WINDOW
        );
        
        return (
            lastAuthTimestamp[deviceId],
            authAttemptCount[deviceId],
            isRateLimited
        );
    }

    /**
     * @dev Admin function to reset auth attempts for a device
     * @param deviceId Device identifier
     */
    function resetAuthAttempts(bytes32 deviceId) external onlyAdmin {
        authAttemptCount[deviceId] = 0;
        lastAuthTimestamp[deviceId] = 0;
    }
}